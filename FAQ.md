# Why are imports being elided in my emit?

# Why are function parameters are bivariant?

# Why are functions with fewer parameters assignable to functions that take more parameters?

# Why are functions returning non-`void` assignable to function returning `void`?

# Why are all types are assignable to empty interfaces?

# Why is `A<string>` assignable to `A<number>` for `interface A<T> { }`?

# Why aren't classes nominal?

# Why are enums nominal?

# Why does `this` get orphaned on my instance methods?

# Why is my output file empty when I use module exports with `--outFile`?

# Decorators on function declarations

# Why are getters without setters not considered read-only?

See [Issue #12](https://github.com/Microsoft/TypeScript/issues/12)

# I wrote `declare var MyComponent: React.Component;`, why can't I write `<MyComponent />`

# Why don't namespaces merge across different module files?

# What's the difference between `enum` and `const enum`s?

# What's the difference between `declare class` and `inteface`?

# Can I make a type alias nominal?

# How do I prevent two types from being structurally compatible?

# What does it mean for an interface to extend a class?

# Why am I getting an error about a missing index signature?

# Why can't I use `x` in `function f({ x: number }) { /* ... */ }`?

# Why don't I get type checking for `(number) => string`?

# How do I check at runtime if an object implements some interface?

# Why doesn't this incorrect cast throw a runtime error?

# How do I write unit tests with TypeScript?

# Why am I getting "TypeError: Cannot read property 'prototype' of undefined" in `__extends` ?
(Derived class put before base class)

# Why do my derived class property initializers overwrite values set in the base class constructor?
See #1617 for this and other initialization order questions

# What does the error "Exported variable [name] has or is using private name [name]" mean?